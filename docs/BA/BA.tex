\documentclass[german,12pt,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage[latin1]{inputenc}
\usepackage[OT1, T1]{fontenc}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{url}
\usepackage[printonlyused]{acronym}
\usepackage[multiple]{footmisc}
\usepackage{lmodern}
\usepackage[numbib]{tocbibind}
\usepackage{ltablex}
\usepackage{tabularx}
\usepackage{supertabular}
\usepackage{multirow}
\usepackage{listings} 
\usepackage[a4paper,left=2.5cm, right=2.5cm]{geometry}
\usepackage{lscape}
\usepackage{pdfpages}
\usepackage{float}
\bibliographystyle{lnig}

% Commands
\newlength{\imgwidth}
\newcommand\scalegraphics[1]{%   
    \settowidth{\imgwidth}{\includegraphics{#1}}%
    \setlength{\imgwidth}{\minof{\imgwidth}{\textwidth}}%
    \centering%
    \includegraphics[width=\imgwidth]{#1}%
}

\title{Bachelorarbeit}
\author{Hendrik Geßner, 751352}
\date{}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\section{Einleitung}

\section{Das bestehende Spiel}

\subsection{Spielidee}

\subsection{Pervasive Games}

\subsection{Existierendes Spiel}

\begin{itemize}
	\item Spielbereich in Vorgängerarbeit~\cite{Dehne.26.April2013} festgelegt. Basis für Entscheidung war Kompromiss aus Geolocation-Genauigkeit und WLAN-Verfügbarkeit.
\end{itemize}

\begin{itemize}
	\item hält sich nicht ganz an AODV
	\item RREQ / RREP / Routenaufbau nicht nach Standard -> kein RREP zurückgesendet
	\item Automatisches Neighbour Find in einfachstem Schwierigkeitsgrad stellt Verknüpfungen zu Nachbarn her (RERR bei verlust des Nachbarn) -> nicht standardkonform
\end{itemize}

\subsection{Verfügbare Hardware}

\begin{itemize}
	\item Lehrstuhl-Smartphones
	\item Lehrstuhl-Tablets
	\item Entwickler-PC
	\item Entwickler-Laptop
	\item WLAN-Router
\end{itemize}

\subsection{Bestehende Software}

\begin{itemize}
	\item Web-Applikation
	\item Backend auf Java-Basis
	\item Frontend auf HTML/CSS/JS-Basis
	\item GWT-Framework
	\item Relationale InMemory-Datenbank H2
\end{itemize}

\subsection{Schwierigkeiten beim Spielen}

In verschiedenen Testläufen mit dem existierenden Spiel sind wiederholt Schwierigkeiten aufgefallen, die das Spielerlebnis beeinträchtigt haben oder die Vorbereitungsphase sehr langwierig machten.

Da für das Spiel immer wieder Smartphones verwendet wurden, die nicht für das RouteMe-System konfiguriert wurden, mussten vor jedem Spiel mit jedem Smartphone folgende Punkte überprüft werden:

\begin{itemize}
	\item WLAN eingerichtet: Jedes Smartphone musste mit dem eingesetzten Router verbunden sein, um mit dem Server kommunizieren zu können. Hilf half der Einsatz von \ac{WPS}.
	\item Akku geladen: Jedes Smartphone musste vollständig geladen sein, um während des Spieles nicht auszugehen. Dabei ist zu beachten, dass die im Spiel genutzten Hardware-Ressourcen Display, GPS-Empfänger und WLAN-Modul besonders energieverbrauchend sind.
	\item URL-Lesezeichen einrichten: Die eingesetzte URL basierte auf einer IP-Adresse und case-sensitiven URL-Bestandteilen. Nicht alle Spieler hatten Vorerfahrung in der Benutzung von Android-Smartphones. Somit stellte sich bereits das Starten eines Browsers oder das Eingeben einer URL auf der Touch-Tastatur als Herausforderung dar. Um beim Spielen zu vermeiden, dass dass die Spieler bei einem Bedienungs-Fehler oder Software-Fehler die URL vollständig eingeben müssen, wurden Lesezeichen auf dem Startbildschirm der Smartphones eingerichtet.
\end{itemize}

Zudem sind verschiedene menschliche Aufgaben in Vorbereitung auf das Spiel notwendig. So müssen alle Spieler in die Funktionsweise und Ziele des Spieles eingeführt werden. Da das Spiel mit wechselnden Gruppen gespielt wurde, wurde jede Gruppe in die Funktionsweise eines Spiel-Interfaces eingeführt, direkt bevor sie dieses Interface verwenden sollte. Da die Instruktoren keine ausgebildeten Trainer sind, ist es vorgekommen, dass die Erklärung zwischen den Gruppen unterschiedlich war. Außerdem konnte es passieren, dass einzelne Punkte besonders ausführlich erklärt oder vergessen wurden.

Zusammenfassend ist festzuhalten, dass die Einrichtung von acht Smartphones etwa zwei Stunden benötigt hat. Zusammen mit der Einrichtung des Servers und des erforderlichen Netzwerkes wurden etwa vier Stunden benötigt.

\begin{itemize}
	\item Übersichtlichkeit in Indoor-UI mangelhaft
	\item Verbindungen zwischen Knoten / aktuelles Netzwerk nur mit Erfahrung oder Zeit zu erkennen
	\item Spiel-Geschwindigkeit und Spieler-Geschwindigkeit passen nicht zusammen -> Routing-Vorgänge fühlen sich langsam an, Spieler bewegen zu schnell, um Routen, die mehr als drei Knoten beinhalten, zu nutzen
\end{itemize}

\begin{itemize}
	\item server ausgelastet
	\item lange, ständig wechselnde ip-basierte addressen
	\item IP muss immer auf jedem einzelnen Client geändert werden
	\item Sehr ähnliche IPs -> automatische vervollständigung des Browsers unnütz, da nicht alle passenden IPs angezeigt
	\item Spielfeld rechteckig entlang längen- und breitengrade, aber nicht drehbar oder in Form änderbar
\end{itemize}

\section{Android-App}

\subsection{GPS}

\begin{figure}
	\centering
	\scalegraphics{pics/gps_sources.png}
	\caption{Mögliche Geolocation-Quellen~\cite{Gardner.2012}}
	\label{fig:gps_sources}
\end{figure}

Geolocation-Daten können aus unterschiedlichen Quellen stammen. Eine Übersicht von Quellen stellt Abbildung~\ref{fig:gps_sources} dar. Die häufigsten Geolocation-Quellen auf den getesteten Smartphones waren WLAN und GPS, wobei WLAN eine Genauigkeit von 20m bis 50m und GPS eine Genauigkeit von 5m bis 15m im vorgesehenen Spielbereich hatte.

Die Design-Philosophie für die Geolocation-Bestimmung isr bei W3C-kompatiblen Browsern und Android-Apps sehr ähnlich. Anstatt die zu verwendende Geolocation-Hardware anzugeben, werden stattdessen die erforderliche Genauigkeit sowie ein Aktualisierungs-Intervall angegeben. Der ausführende Container (also der Browser oder das Android-OS) wählt eine geeignete Datenquelle. Dabei kann der Container eigene Kriterien bei der Auswahl der Geolocation-Quelle einfließen lassen. So präferiert der Safari-Browser des iOS4 aus Energiegründen WLAN gegenüber GPS, obwohl letzteres eine höhere Genauigkeit liefern würde.\footnote{\url{http://stackoverflow.com/questions/6790368/why-is-geolocation-in-mobile-safari-way-less-accurate-than-the-location-in-a-nat}}

Auf den verfügbaren Lehrstuhl-Smartphones benötigt der GPS-Sensor in den meisten Fällen zwischen 30 Sekunden und fünf Minuten, um eine initiale Geolocation zu erhalten. Anschließend wird die Geolocation einmal pro Sekunde aktualisiert. Bei der Nutzung von WLAN-Geolocations war keine initiale Verzögerung zu bemerken. Auch in diesem Fall erfolgt die Aktualisierung einmal pro Sekunde.

\begin{itemize}
	\item Anzahl GPS-Satelliten
	\item Verfahren für Genauigkeit
	\item Hindernisse
	\item Fixierung auf Hardware
	\item Alternativen zu GPS
	\item Erweiterungen von GPS (AGPS, DGPS)
	\item Für DGPS -> Anbieter oder Brandeburg Viewer + Eigene Implementierung
\end{itemize}

\subsection{Abstandsbestimmung auf der Erde}

\begin{itemize}
	\item Erde ist keine Kugel
	\item Abstandsbestimmung zweier Punkte auf Oberfläche über direkten Weg gehen meist durch Oberfläche hindurch
	\item Bei geringem Abstand und Fehlertoleranz kann Fehler vernachlässigt werden
	\item Für unser Szenario ausreichen
	\item GRAFIK FÜR ABSTANDSBERECHNUNG EINFÜGEN
\end{itemize}

\subsection{Entscheidung für eine Android-App}

\begin{itemize}
	\item Browser bieten unzuverlässigen Zugriff auf Sensoren
	\item Auswahl der in Browsern implementierten HTML5-Features noch sehr unterschiedlich\footnote{Es gibt Seiten, die die unterschiedlichen Features der auf dem Markt verfügbaren Browser testen und gegenüberstellen. Eine solche Seite ist \url{http://html5test.com/}, von der die folgende Übersicht stammt: \url{http://html5test.com/compare/browser/android23/android40/operamobile1400.html}, \url{http://html5test.com/compare/browser/chromemobile25/ffmobile19/ios70.html}}
	\item Unterschiedliches Verhalten auf unterschiedlichen Browsern, nicht alle Browser auf allen Betriebssystemen verfügbar: Chrome nur ab Android 4 verfügbar
	\item Darstellung in Browsern unterschiedlich: JS-UI-Framework ignoriert bewusst den Firefox-Browser
	\item 
\end{itemize}

Android bietet
\begin{itemize}
	\item 
\end{itemize}

Eine Festlegung auf Android bringt die folgenden Limitierungen
\begin{itemize}
	\item Plattformunabhängigkeit geht verloren, Festlegung auf Android
\end{itemize}

\subsection{Android-Grundlagen}

\subsubsection{Programmiermodell}

\begin{itemize}
	\item Subject-Observer-Pattern
	\item Besteht aus \texttt{Activity}s und \texttt{Service}s
\end{itemize}

Exceptions, die nicht abgefangen werden, lassen die Applikation abstürzen.

\subsubsection{Lebenszyklus}

HIER BILD AUS ANDROID-DOKU!

\subsubsection{Rechtemanagement}

Um Zugriff auf Hardware-Ressourcen oder sensible Informationen zu erlangen muss die Applikation vorher diese Rechte am System anmelden. Dies geschieht über das \texttt{ApplicationManifest}, in dem die benötigten Rechte eingetragen werden. Vor der Installation der Applikation bekommt der Benutzer eine Übersicht über die für die Applikation erforderlichen Rechte. Mit der Installation werden der Applikation die eingetragenen Rechte gewährt. Rechte werden immer vollständig gewährt. Es ist nicht möglich, Rechte im Nachhinein zu entziehen oder einzuschränken.

Typische Rechte sind der Zugriff auf das Internet, Zugriff auf den GPS-Empfänger oder Zugriff auf die auf dem Smartphone gespeicherten Kontaktdaten.

\subsubsection{UI-Thread}

Wie viele andere Desktop-UIs setzt auch Android auf ein UI-Thread-Modell. Änderungen an GUI-Elementen dürfen nur auf dem UI-Thread durchgeführt werden. Versuche, Änderungen außerhalb des UI-Threads durchzuführen, werden mit Exceptions zurückgewiesen.

Um Änderungen auf dem UI-Thread durchzuführen müssen Aufgabenblöcke, in Java \texttt{Runnable}s, explizit auf den UI-Thread geschoben werden.

\subsubsection{Hintergrundoperationen}

Es gibt verschiedene Möglichkeiten, Operationen im Hintergrund laufen zu lassen:

\begin{itemize}
	\item Android-AsyncTasks
	\item Android-Services
	\item Java-Threads
\end{itemize}

\paragraph{AsyncTasks} Hintergrundoperationen, die nur für eine sehr begrenzte Zeit laufen, können in einem \texttt{AsyncTask} durchgeführt werden. Aus Kompatibilitätsgründen wird pro Applikation und zu jedem Zeitpunkt standardmäßig immer nur ein \texttt{AsyncTask} ausgeführt. Ein \texttt{AsyncTask} muss vom UI-Thread gestartet werden. Android übernimmt die Bearbeitung im Hintergrund. Bei Beendigung der Bearbeitung wird eine Methode mit dem Ergebniss der Hintergrund-Aufgabe aufgerufen. Android stellt sicher, dass diese Methode im Kontext des UI-Threads läuft. Somit können UI-Manipulationen, die auf dem Ergebnis der Hintergrundoperation beruhen, ohne weiteren Aufwand durchgeführt werden.

\paragraph{Services} Lange Hintergrundoperationen, die unabhängig von der GUI laufen sollen, können in Services durchgeführt werden. Wie eine \texttt{Activity} hat auch ein \texttt{Service} einen eigenen Lebenszyklus. Die Bindung zwischen \texttt{Activity} und \texttt{Service} wird beim Erstellen des \texttt{Service} festgelegt. \texttt{Service} und \texttt{Activity} können unabhängig voneinander arbeiten und undabhängig voneinander Lebenszyklus-Phasen durchlaufen.

\paragraph{Threads} Die aus der Java-Welt bekannten Threads sind auch in Android verfügbar. Sie bieten feingranulare Zugriffs- und Einstellungsmöglichkeiten für parallele Verarbeitung, bieten aber keine Unterstützung für die Manipulation des UI-Thread. Sie sind am besten als Zwischenstufe für die Portierung von Java-Code auf Android-Systeme geeignet.

\subsubsection{Fragments}

Aus Einzelblöcken zusammengesetzte UI-Elemente, die wiederverwendet werden können, heißen \textit{Fragments}. Diese haben ein eigenes Layout und eigenen Java-Code. Kommunikation mit \textit{Fragments} erfolgt über Interfaces. Um die Übersichtlichkeit in Applikationen zu erhalten, wird empfohlen, logisch zusammenhängende Einheiten in \textit{Fragments} zu kapseln.

Eines der bekannten \textit{Fragments} ist das \texttt{SupportMapFragment} für Googles Maps-Service.

\subsubsection{Sensoren}

Android-Smartphones besitzen eine Vielzahl von verfügbaren Sensoren. Dazu gehören unter anderem GPS-Empfänger, Beschleunigungs- und Lage-Sensoren. Die Vielzahl an automatisch auslesbaren Sensoren machen Smartphones besonders interessant für pervasive Anwendungen. Die große Verbreitung von Android sorgt dabei für eine Vielzahl an unterschiedlichen Smartphones mit sehr verschiedenen Konfigurationen und Ausstattungen.

Android bietet einfachen Zugriff auf die verfügbaren Sensoren. Die Applikation ist dabei selbst verantwortlich, sich an das verfügbare System anzupassen und nicht vorhandene Sensoren zu kompensieren. Sensoren werden über den \texttt{SensorManager} angesprochen. Android verwendet auf für Sensoren das \textit{observer pattern}. Im Folgenden werden drei Sensoren vorgestellt, die in der Arbeit verwendet wurden.

\begin{itemize}
	\item Motion-Sensor
	\item Tilt-Sensor
	\item GPS-Sensor
\end{itemize}

\subsubsection{APIs}

\begin{itemize}
	\item Google Maps -> Play Services
	\item Einbindung von Google Maps
	\item Deployment und API-Keys
	\item Aufbau und Benutzung sehr ähnlich zu JS-API Version 3
\end{itemize}

\subsubsection{Einbindung von Drittbibliotheken}

Wie von Java bekannt können externe Bibliotheken über JAR-Archive eingebunden werden. Dabei ist allerdings ganz besonders auf die Kompatibilität mit der Android-VM zu achten. Android bietet nur eine Untermenge der aus der Java-API bekannten Klassen und Interfaces an. Somit lassen sich viele Bibliotheken nur mit Anpassung des Quellcodes nutzen.

Das Android-Eclipse-Plugin ermöglicht die Erstellung von Android-Bibliotheken. Eine Android-Bibliothek ist ein Android-Projekt, bei dem das \texttt{android.library}-Flag gesetzt ist. Android-Bibliotheken sind nicht ausführbar und können deshalb auch nicht separat getestet werden. Android-Bibliotheken können sowohl von Android-Projekten als auch von Java-Projekten verwendet werden. Im Gegensatz dazu können Java-Projekte nicht als Bibliotheken in Android-Projekten eingebunden werden.

\subsubsection{Audio}

\begin{itemize}
	\item Audio muss beantragt werden
	\item Für kurze Audio-Schnippsel gibt es ein besonderes Flag, das Hintergrundgeräusche / Hintergrundmusik nicht stoppt, sondern nur herunterregelt
\end{itemize}

\subsection{Portierung}

\begin{itemize}
	\item Portierung von JS nach Android-Java
	\item Struktur des Codes übernehmen
	\item bereits Erfahrung in der Portierung von PHP nach Java
	\item kopieren / einfügen, anschließend an Java-Syntax anpassen
	\item Wrapper für UI-Elemente und Browser-Funktionen
	\item UI vollständig anders umsetzen
	\item Einstieg an Android-Gegebenheiten anpassen
\end{itemize}

\begin{itemize}
	\item Konzept des UI-Threads in JS unbekannt, UI-Elemente können beliebig verändert werden. Android hat einen UI-Thread und alle Manipulationen, die nicht innerhalb des UI-Thread durchgeführt werden.
	\item Dieses Verhalten muss bei der Portierung beachtet werden. Deshalb in Wrapperklassen dieses Verhalten nachbilden
\end{itemize}

\subsection{Umsetzung von Pervasivität}

\begin{itemize}
	\item Schüttel-Gesten für Einsammeln
	\item Audio-Feedback für Ping aussenden / empfangen
	\item Vibrations-Feedback für Ping empfangen
	\item Pervasive Karte
	\item Items an Horizont
\end{itemize}

\subsection{Umsetzung von Pervasivität}

\begin{itemize}
	\item Shake-Modul entwickelt
	\item Modul für selbstdrehende Karte entwickelt (Umsetzung über Lagesensor und Kompass)
	\item WLAN-Verbindungs-Modul entwickelt
\end{itemize}

\subsection{Spielerleichterungen}

\begin{itemize}
	\item Nutze Möglichkeit, Android-Apps per URL zu starten
	\item Parameterübergabe für WLAN-SSID und WLAN-Schlüssel über URL-Parameter
	\item Nachteil: Kein Aufruf von URLs ohne Netzwerkverbindung. Nicht klar, warum dem so ist
	\item Workarounds: QR-Reader aus App heraus starten. Nachteil: Abhängigkeit von bestimmter QR-App, die installiert sein muss
	\item Alternative: Bild selbst untersuchen. Hoher Eigenaufwand
	\item QR-Code wird bei Spielerstellung generiert. PDF mit QR-Code und kodierten Daten wird erstellt
\end{itemize}

\begin{itemize}
	\item QR-Code-Starten gestestet
	\item Start über beliebige externe App
	\item Überraschenderweise benötigen QR-Reader eine Netzwerk-Verbindung, um eine URL zu öffnen, auch wenn die URL nur einen Start der App auf dem Smartphone bewirkt. 
Auf den Test-Smartphones des Lehrstuhles ist keine SIM-Karte eingelegt, somit ist keine Verbindung über 2G / 3G / 4G möglich. Bei einem Smartphone, bei dem WLAN unkonfiguriert ist, ist außerdem keine Netzwerkverbindung vorhanden. Dieses Verhalten verhindert, dass die App gestartet werden kann. Eine Idee der App war, dass beim Start über einen QR-Code das Smartphone sich mit dem im QR-Code kodierte WLAN verbindet.
\end{itemize}

\subsection{QR-Codes}

\begin{itemize}
	\item QR-Tags sind Schwarz-Weiß-Muster
	\item Pervasive-Computing-Vorlesung
	\item Benötigte Hardware: Kamera
	\item Rest: Softwarelösung
	\item Einfach in Herstellung, günstig, viele Leser
\end{itemize}

\subsection{WiFi}

\begin{itemize}
	\item Kommunikation mit Server
	\item Alternative: GPRS / UMTS
	\item Smartphones nicht mit SIM-Karte ausgestattet -> kein Zugriff auf diese Netze
\end{itemize}

\section{Anpassung für Level 2}

\subsection{AODV}

\ac{AODV} ist Routing-Algorithmus, der für \ac{MANETs} ausgelegt ist. Jeder Knoten ist gleichberechtigt. Durch das Versenden und Weiterleiten von Nachrichten an Nachbarn entsteht ein Netzwerk. Dieses Netzwerk ist ständigen Veränderungen unterworfen, da sich Nachbarschaftsverhältnisse ändern und Knoten ausfallen können. Diese Veränderungen erfordern eine permanente Anpassung der Routen.

\ac{AODV} gehört zu den reaktiven Routing-Algorithmen. Routen werden erst bei Bedarf ermittelt. Alle an der Route beteiligten Knoten überwachen die Aktualität und senden Fehlernachrichten, falls eine Route ausfällt.

Es wird an einem Nachfolger namens AODVv2 gearbeitet.

\subsubsection{RREQ und RREP}

Routen werden über eine Kombination von \ac{RREQ} und \ac{RREP} gefunden. Benötigt ein Quellknoten eine Route zu einem Zielknoten, so sendet er einen \ac{RREQ} an alle Nachbarknoten. Jeder Nachbarknoten überprüft, ob er bereits eine Route zum Zielknoten kennen. Falls eine Route bekannt zum Zielknoten bekannt ist oder falls der Knoten selbst der Zielknoten ist, so sendet er einen \ac{RREP} an den Quellknoten zurück. Ist keine Route bekannt, so leitet er den \ac{RREQ} an seine eigenen Nachbarknoten weiter. Nachbarknoten speichern eine Route zum Quellknoten des \ac{RREQ}.

\subsubsection{Hello-Nachrichten}

Knoten können Hello-Nachrichten versenden, um ihren Nachbarn Ver\-bin\-dungs-In\-for\-matio\-nen zu Verfügung zu stellen. Dabei sollen Hello-Nachrichten nur verwendet werden, wenn der aussendende Knoten teil einer aktiven Route ist. Bleiben Hello-Nachrichten für einen bestimmten Zeitraum aus, so kann der empfangende Knoten davon ausgehen, dass die Route ausgefallen ist.

\subsubsection{RERR}

Fällt eine Route aus, so wird ein \ac{RERR} versendet. Empfangende Knoten können anhand des \ac{RERR} ihre Routen-Einträge korrigieren.

\subsection{Hello-Nachrichten}

Benutzer finden sich untereinander nur noch, wenn sie einen Ping aussenden. Wie soll der Prozess des Findens und Haltens von Nachbarn umgesetzt werden?

Blick auf das AODV-Protokoll: Knoten senden regelmäßig HELLO-Nachrichten aus. Wenn HELLO-Nachrichten zu lange ausbleiben wird Abbruch der Verbindung angenommen, Routing-Tabelle aktualisiert und RERR gesendet.

HELLO-Nachrichten werden nur gesendet, wenn Knoten Teil einer aktiven Route ist. Außerdem tragen HELLO-Nachrichten eine Sequence-Number in sich, die zur Bestimmung der Aktualität von Routen verwendet wird.

\begin{itemize}
	\item Spielidee: Knoten bekommen Punkte für den Aufbau einer Route. Vermutung: Dadurch wird das Aufbauen von Routen gestärkt, was auch der Sinn eines MANETs ist. Außerdem sollen HELLO-Nachrichten laut RFC nur gesendet werden, wenn Knoten Teil einer aktiven Route ist. Deshalb muss für die sinnvolle / standardkonforme Nutzung von HELLO-Nachrichten der Aufbau von Routen gefördert werden.
	\item Ziel: Routenbewusstsein stärken? Idee: Aktive Routen anzeigen. Einwand: Wenig Platz auf Smartphone-Screen, da Button für Gegenstand einsammeln und ein paar Gegenstands-Informationen sowie Hilfstexte verwendet wird. Lässt sich dieser Platz besser nutzen? Ja!
\end{itemize}

Umsetzung auf Mobile: Spieler senden Pings manuell aus. Sollen sie Nachbarn finden, indem sie selbst einen Ping aussenden (Aktiv-Sonar eines U-Bootes) oder sollen sich Nachbarn zeigen, indem der Spieler ihren Ping empfängt?

Häufigkeit der Pings: Spieler sollten nicht durchgehend ohne Nachteil pingen können, da sonst Effekt des manuellen Pings verloren geht. Verschiedene Möglichkeiten:

\begin{itemize}
	\item Bestimmte Anzahl an Pings für Spieler verfügbar, neue werden zeitlich oder über Item verfügbar
	\item Pings sind nur mit Cooldown verfügbar
	\item Pings haben Malus-Effekt (z.B. auf Batterie oder Punkte)
\end{itemize}

Wie werden Nachbarschaftsverhältnisse wieder aufgebhoben? Sollen Nachbarschaftsverhältnisse automatisiert aufgehoben werden?

Blick auf AODV-Protokoll: Für HELLO-Nachrichten gilt ein HELLO\_INTERVAL und ein ALLOWED\_HELLO\_LOSS. Daraus ergibt sich, wann Routen als ungültig erkannt werden sollen.

\begin{itemize}
	\item Spielerische Idee: Vor Ablauf des HELLO\_INTERVAL*ALLOWED\_HELLO\_LOSS den Knoten warnen, der das HELLO ausgesendet hat, damit seine Routen und gültigen Nachbarn nicht verloren gehen. So lässt sich leichter ein Gefühl für HELLO\_INTERVAL entwickeln.
\end{itemize}

\subsection{Nachrichtenversand}

Auf Level zwei dürfen Routen nicht mehr selbst gewählt werden sondern müssen aus einer Liste von Vorgaben ausgewählt werden. Was soll auf dem Auswahlfeld angezeigt werden?

\begin{itemize}
	\item Nickname der Knoten, zwischen denen geroutet werden soll. Nicknamen sind keine Beschränkungen auferlegt, außerdem geben Nicknamen keine Auskunft über Position / Status / Distanz der Route / Punkte der Route etc. Indoor-Spieler bauen bisher keine Verbindung zu einzelnen Knoten (also Verknüpfung von Nickname und Position / Verhalten), was bringen also Nicknames?
	\item Alternative: Distanz / Anforderung / Vermutete Punkte / Vermutete Hops
	\item Außerdem: Bonus-Eigenschaft
	\item Bei Maus-Hover: Start- und Zielknoten auf Karte hervorheben
\end{itemize}

Welche Routen sollen zur Verfügung gestellt werden?

\begin{itemize}
	\item Nur derzeit verknüpfte Wege
	\item Beliebige Auswahl an Knoten. Bei 6 Knoten sind das 15 ($\frac{n*(n-1)}{2}$) mögliche Wege. Bei Bidirektionalität sogar 30.
\end{itemize}

\subsection{Nachrichtenversand}

\begin{itemize}
	\item Ziel: Möglichst viel Code behalten, um Aufwand gering zu halten
	\item Mix aus GWT und JS
	\item Originaler JS-Code für Maps erhalten, Click wird in JS an Server gesendet
	\item Bei Update von Server wird Subset von Infos per JSNI nach GWT gegeben
	\item GWT-UI reagiert darauf
	\item Einfach und gut
\end{itemize}

\begin{itemize}
	\item Routen werden per Zufall zwischen den verfügbaren Knoten in Client erstellt
	\item Verhindert Server-Eingreifen und Server-Unterstützung
\end{itemize}

\paragraph{JS-Testing} Verwendung von Karma (vormals Testacular) als Testrunner, Jasmine als Framework.

\subsection{Hello-Nachrichten}

\begin{itemize}
	\item Auf Serverseite: Verbindungen bekommen Last-Ping-Timestamp
	\item Anzeigeideen hinter Ping-Feedback
	\item Synchronisierter Timestamp
	\item Mit Server synchronisierter Timestamp
	\item Server verbirgt Timestamp, arbeitet intern mit Server-Timestamp
	\item Knoten senden ping und ping-invalidate
\end{itemize}

\begin{itemize}
	\item In Verbindungstabelle ist last-ping angegeben.
	\item Statischer Malus für jeden Ping von fünf Batterie-Punkten
	\item Punkte für Nachbar haben bleibt gleich
\end{itemize}

\subsection{Visualisierung von Nachbarn}

\begin{itemize}
	\item Knoten-Screenshot von Raphael
	\item Gegenüberstellung altes vs. neues System
	\item Verdeutlichung von Netzwerken
	\item Aufgefallen bei Spieleinführung: Zur Verdeutlichung von Netzwerken wurden Folien mit Verbindungslinien verwendet, diese Linien waren aber im Spiel nicht zu sehen
\end{itemize}

\subsection{GWT / JSNI}

\begin{itemize}
	\item GWT ermöglichte Integration von bestehendem JS-Code mit im Rahmen des Refactoring erzeugtem Java-Code.
\end{itemize}

\section{Optimierungspotential}

\begin{itemize}
	\item Dynamisches DNS verhindert IP-Umstellung auf Clients
\end{itemize}

\subsection{Skalierbarkeit}

\begin{itemize}
	\item Zwei Standpunkte: Beserer Server oder stärkere Clients
	\item Serverlosigkeit mit PushFork
	\item RESTful-Philosophie umsetzen über dokumentbasiertes Vorgehen
\end{itemize}

\subsection{Überlegungen zur Kommunikation zwischen Client und Server}

\subsubsection{Rest / RESTful}

\begin{itemize}
	\item Begriff REST von Roy Fielding eingeführt~\cite{Fielding.2000}
	\item Basiert auf grundlegenden Internet-Technologien wie URI, HTTP
	\item Verwendet HTTP-Verben wie GET, POST, PUT um dokumentbasierte Kommunikation zwischen Client und Server zu ermöglichen
	\item Roy Fielding plädiert auf intensive Nutzung des HTTP-Standards, um bestehende WWW-Infrastruktur optimal auszunutzen
	\item Er betont ausgiebig die bestehenden Client-Server-Architekturen unter Einbeziehung von Caches, Firewalls und Proxies
	\item Roy Fieldings Arbeit bleibt sehr abstrakt, weshalb sich viele Interpretationen des REST-Konzeptes herausgebildet haben~\cite{Richardson.2007}
	\item Viele Probleme und Missverständnisse in der Umsetzung\footnote{\url{http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven}}\footnote{\url{https://weblogs.java.net/blog/mkarg/archive/2010/02/14/what-hateoas-actually-means}}
	\item Nach Fielding soll Kommunikation soweit wie möglich mit HTTP durchgeführt werden, ohne HTTP nur als Transportprotokoll für erweiterte Formate einzusetzen. Für die Umsetzung von speziellen Anforderungen empfiehlt er die Verwendung von (eigenen) HTTP-Erweiterungen
	\item Media type ist Schlüsselbestandteil in REST (siehe Zitat am Ende der Tabelle)
	\item Beschreibung der media types im Gegensatz Beschreibung von URL-Bau-Schemata. Alle Informationen, die zum Bau von URLs als Zustandsübergänge nötig sind, sollen in den übertragenen Informationen stecken
	\item Starker Fokus auf Zustandslosigkeit: Alle Informationen, die ein Client benötigt, sollen in den übertragenen Informationen enthalten sein. Informationen für Zustandübergänge sollen in diesen Informationen enthalten sein. Es gibt nur einen URL-Einstiegspunkt in die Applikation, alle anderen URLs werden von dort aus ermittelt
\end{itemize}

\begin{quotation}
A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types. Any effort spent describing what methods to use on what URIs of interest should be entirely defined within the scope of the processing rules for a media type (and, in most cases, already defined by existing media types).\footnote{\url{http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven}}
\end{quotation}

\begin{itemize}
	\item Was bedeutet das für RouteMe?
	\item Media types müssen definiert werden, anstatt application/json zu verwenden
	\item URLs müssen generiert werden, z.B. zum Einsammeln von Items
\end{itemize}

\begin{itemize}
	\item Gegenüberstellung Dokumentbasiert vs. RPC vs. Hybrid~\cite{Richardson.2007}
	\item XML-RPC zeichnet sich dadurch aus, als HTTP-Verb POST verwendet wird, HTTP nur das Trägermedium bildet und alle relevanten Informationen für den Aufruf (Kontext, Operation, Daten) im transportierten XML stehen. Die URL bleibt für alle Aufrufe die gleiche
	\item Dokumentbasiert verwendet die HTTP-Verben, um die Operation auszudrücken, eine URL, um den Kontext auszudrücken und HTTP-Content, um die Daten zu übertragen
\end{itemize}

\begin{itemize}
	\item GWT setzt auf XML-RPC
	\item GWT kann auch REST-Kommunikation abbilden\footnote{\url{http://restygwt.fusesource.org/}}\footnote{\url{https://code.google.com/p/gwt-rest-client/}}\footnote{\url{https://code.google.com/p/gwt-rest/}}
	\item GWT wird auf Admin- und auf Indoor-Seite eingesetzt
	\item REST wird auf Indoor- und auf Mobile-Seite eingesetzt
	\item Vereinheitlichung sinnvoll:
	\item Weniger Wartungsaufwand: Verschiedene Schnittstellen erfordern verschiedene Frameworks. Wenn nur eine Schnittstelle angeboten wird, dann muss auf Änderungen in der Kommunikation nur innerhalb einer Architektur-Philosophie und nur unter Nutzung eines Technologie-Stacks reagiert werden
	\item Wiederverwendbarkeit gleicher Schnittstellen zwischen unterschiedlichen Interfaces
	\item Wiederverwendbarkeit gleicher Schnittstellen zwischen unterschiedlichen Implementationen
\end{itemize}

\subsubsection{Ein- und Ausgabeformate}

\begin{itemize}
	\item Nicht festgelegt
	\item XML und JSON am häufigsten
\end{itemize}

\subsubsection{Hyperlinks}

\begin{itemize}
	\item XML hat XLink~\cite{W3C.06.05.2010}
	\item JSON fehler Hyperlinks, allerdings verschiedene Projekte, um Erweiterung zu realisieren\footnote{\url{http://www.mnot.net/blog/2011/11/25/linking_in_json}}
	\item Verschiedene Ansätze, JSON um Links zu erweitern, bisher kein Standard
\end{itemize}

\subsubsection{Ausführungsort von Code}

\begin{itemize}
	\item Wo wird was ausgeführt (Schichten-Grafik)
	\item Wo sollen die rechenintensiven Aufgaben durchgeführt werden?
	\item Option 1: Alles auf Clients, Server nur für Kommunikation innerhalb der Clients benötigt, z.B. mittles PushFork\footnote{\url{http://pushfork.com/}}
	\item Option 2: Alles auf Server, Clients nur als Anzeige benötigt
	\item Option 3: Statische Aufteilung der Aufgaben von Server und Client
	\item Option 4: Dynamische Aufteilung der Aufgaben von Server und Client über Code-on-demand~\cite{Fielding.2000}
\end{itemize}

\subsection{Überlegungen zur Datenbankstruktur}

\subsubsection{Datenbank Event-basiert umbauen}

\subsubsection{Gemeinsames Repräsentationsformat für Routing-Pakete}

\begin{itemize}
	\item Jedes Routing-Protokoll hat eine eigene Repräsentation von Datenpaketen. MANET Working Group versucht, Datenformat für künftige MANET-Routing-Algorithmen zu vereinheitlichen~\cite{InternetEngineeringTaskForce.02.2009}. AODVv2 und OLSRv2 sind auf dieses vereinheitlichte Format ausgerichtet~\cite{InternetEngineeringTaskForce.23.03.2013, InternetEngineeringTaskForce.12.03.2013}, für ältere Algorithmen wie AODV, OLSR und DSR sind noch eigene Formate definiert~\cite{InternetEngineeringTaskForce.July2003, InternetEngineeringTaskForce.10.2003, InternetEngineeringTaskForce.02.2007}.
	\item Um Entkopplung innerhalb von Datenbank und Spiellogik zu erreichen, ist gemeinsame Basis empfehlenswert. Schichtenmodell als Möglichkeit.
	\item Repräsentation auf View-Seite flexibel, da derzeit nur angezeigt wird, wo abgeschicktes Paket gerade ist (Indoor) und wie viele Pakete gerade warten (Indoor, Mobile)
	\item Repräsentation auf View-Seite wird detailierter, sobald AODV-Level 3 implementiert ist
\end{itemize}

\begin{itemize}
	\item Weitere Möglichkeit der Aufteilung: Nutzung einer Dokument-orientierten Datenbank gegenüber einer relationalen Datenbank. Vorteil: Dokumentorientierung ist auf Ablegen und Durchsuchen von unstrukturierten Daten spezialisiert. Dokumentorientierte Datenbanken verwenden keine Tabellen-Schemata. Relationale Datenbanken unterstützen dieses Vorgehen durch simulierte Vererbung, sodass jeder Routing-Algorithmus eine eigene Tabelle pro verwendetem Paketformat hätte, wobei alle Tabellen auf eine Obertabelle verweisen.
	\item Vorteil Dokumentorientierung: Keine Schema, dadurch gesicherte Abwärtskompatibilität im laufenden Betrieb.
	\item Brauchen wir diesen Vorteil? Nein, da Datenbanken nur von Spiel zu Spiel benötigt werden, Spiele auf Laufzeiten im Minuten- oder Stundenbereich angelegt sind und keine Daten zwischen Spielen gehalten werden
	\item Hibernate ist auf relationale Datenbanken ausgerichtet\footnote{\url{http://www.hibernate.org/about/orm.html}}
\end{itemize}

\section{Evaluierung}

\begin{itemize}
	\item Evaluation in großem Stil -> Julians Arbeit~\cite{JulianDehne.201204.03.2013E}
	\item Aus Zeitgründen war eine Evaluation des Lernerfolges nicht möglich
	\item Deshalb: Funktionale Evaluation
\end{itemize}

Szenario: Ping versenden

\begin{enumerate}
	\item Spiel starten
	\item 
\end{enumerate}

Szenario: Ping empfangen

Szenario: Gegenstand einsammeln

Szenario: Nachricht versenden

\subsection{Codestruktur}

\begin{itemize}
	\item Einsatz von ReSharper 101
	\item ReSharper-Metrik "`Fat"' und "`Tangled"'
\end{itemize}

\section{Zusammenfassung / Ausblick}

\begin{itemize}
	\item QR-Code-Lesen aus App heraus, z.B. über ZXing\footnote{\url{https://code.google.com/p/zxing/}}
	\item Portierung der bisherigen Kommunikation nach REST
	\item Portierung der Datenbank und Datenbankabfragen auf Event-getriebene Struktur
\end{itemize}

\begin{itemize}
	\item Spielerische Aspekte stärken
	\item Ausscheiden von Knoten: AODV definiert Reboot-Verfahren
	\item Audio einbinden: Bei Ping senden / Ping empfangen
	\item Vibration einsetzen: Bei Ping empfangen
	\item Ablauf eines Pings verdeutlichen
\end{itemize}

\begin{itemize}
	\item App benötigt noch viele Anpassungen
	\item Weitere Level
	\item Anzeige, wann Ping ausläuft
	\item Stärkere Annäherung an Android best practices
	\item Aufteilung in Async Tasks
	\item Stärkere Entkopplung von Komponenten, um Wiederverwendbarkeit in anderen Android-Applikationen zu ermöglichen
\end{itemize}

\begin{itemize}
	\item QR-Code-Generierung in Admin-Frontend einbauen
	\item Abhängigkeit von externem QR-Reader lösen
	\item Abhängigkeit von Netzwerk lösen, WLAN-Funktionalität sonst witzlos
\end{itemize}

\begin{itemize}
	\item Indoor-Routen ein- und ausanimieren
	\item UI-Anpassungen im Indoor
\end{itemize}

\section{Abkürzungsverzeichnis}

\begin{acronym}[YTM]
\setlength{\itemsep}{-\parsep}
\acro{AODV}{Ad hoc On-Demand Distance Vector}
\acro{MANETs}{Mobile Ad-hoc-Netzwerke}
\acro{RREQ}{Route Request}
\acro{RREP}{Route Reply}
\acro{RERR}{Route Error}
\acro{WPS}{Wi-Fi Protected Setup}
\end{acronym}

\bibliography{literatur}

\end{document}
