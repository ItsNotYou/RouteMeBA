<?php

/**
 * Player
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Player extends BasePlayer
{
	public function updateNeighbourhood($isUnitTest = false) {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		$query = Doctrine_Query::create();
		$query->select("p.*");
		$query->addSelect("( 6371 * acos( cos( radians({$this->latitude}) ) * cos( radians( p.latitude ) ) * cos( radians( p.longitude ) - radians({$this->longitude}) ) + sin( radians({$this->latitude}) ) * sin( radians( p.latitude ) ) ) ) distance");
		$query->from("Player p");
		$query->where("id != ? AND role = ? AND battery > ?", array($this->id, PLAYER_ROLE_NODE, 0));
		$query->having("distance <= ".$gameSettings->baseNodeRange / 1000); //FIMI ? warum baseNodeRange durch 1000
		$query->orderBy("distance");

		$results = $query->execute();
		$keyValueArray = $results->toKeyValueArray('id', 'name');

		// nach nicht mehr aktuellen Nachbarn suchen
		foreach ($this->Neighbours as $theNeighbour) {
			// Spieler ist nicht mehr Nachbar, wenn er in der Abfrage der aktuellen Nachbarn nicht mehr auftaucht
			if (is_null($keyValueArray[$theNeighbour->neighbourId])) {
				// Aktionen für das AODV Protokoll durchführen
				if ($gameSettings->protocol == "aodv") {
					// RERRs senden
					$theNeighbour->Neighbour->sendRouteErrorToNeighbours($theNeighbour->neighbourId, $isUnitTest);
					// betroffene Routingtabelleneinträge löschen
					Doctrine_Query::create()->from("AODVRoutingTableEntry")->where("nodeId = ? AND nextHopId = ?", array($this->id, $theNeighbour->neighbourId))->execute()->delete();
				}
				// Nachbar entfernen
				$theNeighbour->delete();
			}
		}

		// alle neuen Nachbarn eintragen
		foreach ($results as $thePlayer) {
			$existingNeighbour = Doctrine_Query::create()->from("Neighbour")->where("nodeId = ? AND neighbourId = ?", array($this->id, $thePlayer->id))->execute()->getFirst();
			// Nachbar existiert noch nicht in der Liste
			if(empty($existingNeighbour)) {
				$newNeighbour = new Neighbour;
				$newNeighbour->nodeId = $this->id;
				$newNeighbour->neighbourId = $thePlayer->id;
				$newNeighbour->save();	

				// wenn Protokoll AODV ist, dann neuen Eintrag in Routingtabelle vornehmen
				if ($gameSettings->protocol == "aodv") {
					$newRoutingTableEntry = new AODVRoutingTableEntry;
					$newRoutingTableEntry->nodeId = $this->id;
					$newRoutingTableEntry->destinationId = $thePlayer->id;
					$newRoutingTableEntry->nextHopId = $thePlayer->id;
					$newRoutingTableEntry->destinationSequenceNumber = ++$currentPlayer->sequenceNumber;
					$newRoutingTableEntry->hopCount = 1;
					$newRoutingTableEntry->timestamp = time();
					$newRoutingTableEntry->save();

					$this->save();
				}
			} 
		}
	}
	
	// Entfernung zu anderem Knoten in km
	public function calculateDistanceWithPlayer($theOtherNode) {
		$R = 6378.137; // Erdradius in km

		$lat1 = deg2rad($this->latitude);
		$lat2 = deg2rad($theOtherNode->latitude);
		$lon1 = deg2rad($this->longitude);
		$lon2 = deg2rad($theOtherNode->longitude);
		if ($lat2 == 0 and $lon2 == 0) continue;
		$a = acos(sin($lat1)*sin($lat2) + cos($lat1)*cos($lat2)*cos($lon2-$lon1));
		$d = $R * $a;
		
		return $d;
	}
	
	// Sendereicheite in Metern
	public function getRange() {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		if ($this->hasSignalRangeBooster > 0) {
			return $gameSettings->baseNodeRange + 4;
		} else {
			return $gameSettings->baseNodeRange;
		}
	}
	
	public function nodeIsInRange($theNode) {
		return $this->calculateDistanceWithPlayer($theNode) <= $this->getRange() / 1000;
	}
	
	public function getNeighbours() {
		$neighbours = Doctrine_Query::create()->from("Neighbour")->where("nodeId = ?", $this->id)->execute();
		
		return $neighbours;
	}
	
	public function getNearbyItems() {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		$query = Doctrine_Query::create();
		$query->select("i.*");
		$query->addSelect("( 6371 * acos( cos( radians({$this->latitude}) ) * cos( radians( i.latitude ) ) * cos( radians( i.longitude ) - radians({$this->longitude}) ) + sin( radians({$this->latitude}) ) * sin( radians( i.latitude ) ) ) ) distance");
		$query->from("Item i");
		$query->having("distance <= ".$gameSettings->baseNodeRange / 1000);
		$query->orderBy("distance");

		return $query->execute();
	}
	
	public function getNearestItemDistance() {
		$query = Doctrine_Query::create();
		$query->select("i.*");
		$query->addSelect("( 6371 * acos( cos( radians({$this->latitude}) ) * cos( radians( i.latitude ) ) * cos( radians( i.longitude ) - radians({$this->longitude}) ) + sin( radians({$this->latitude}) ) * sin( radians( i.latitude ) ) ) ) distance");
		$query->from("Item i");
		$query->orderBy("distance");
		$theItem = $query->execute()->getFirst();
		
		return $theItem->distance * 1000;
	}
	
	public function getItemInCollectionRange() {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		$query = Doctrine_Query::create();
		$query->select("i.*");
		$query->addSelect("( 6371 * acos( cos( radians({$this->latitude}) ) * cos( radians( i.latitude ) ) * cos( radians( i.longitude ) - radians({$this->longitude}) ) + sin( radians({$this->latitude}) ) * sin( radians( i.latitude ) ) ) ) distance");
		$query->from("Item i");
		$query->having("distance <= ".$gameSettings->itemCollectionRange / 1000);
		$query->orderBy("distance");
		$theItem = $query->execute()->getFirst();
		
		return $theItem;
	}
	
	// AODV spezifische Methoden
	
	public function getRouteToDestination($destinationId) {
		return Doctrine_Query::create()->from("AODVRoutingTableEntry")->where("nodeId = ? AND destinationId = ?", array($this->id, $destinationId))->orderBy("hopCount asc")->execute()->getFirst();
	}
	
	public function addRouteRequestToBuffer($theRequest, $isUnitTest = false) {
		// Debugging
		if (!$isUnitTest) echo "RREQ mit sourceId {$theRequest->sourceId} und sequenceNumber {$theRequest->sequenceNumber} zum Puffer hinzufügen.\n";
		
		$newBufferEntry = new AODVRouteRequestBufferEntry;
		$newBufferEntry->nodeId = $this->id;
		$newBufferEntry->sourceId = $theRequest->sourceId;
		$newBufferEntry->sequenceNumber = $theRequest->sequenceNumber;
		$newBufferEntry->save();
	}
	
	public function createRouteForRREQ($theRequest, $hopCountModifier = 0) {
		// RREQ in Buffer eintragen
		$this->addRouteRequestToBuffer($theRequest, false);
		
		// Debugging
		echo "Route für RREQ mit sourceId {$theRequest->sourceId} und sequenceNumber {$theRequest->sequenceNumber} erstellen.\n";
		
		$hopCount = 1 + $hopCountModifier;
		// Route rückwärts gehen
		$backwardsRoute = array_reverse($theRequest->passedNodes);
		$lastNodeId = $this->id;
		foreach($backwardsRoute as $theNodeId) {
			$useRoute = false;
			// alte Routen zum Ziel betrachten
			$oldRoutes = Doctrine_Query::create()->from("AODVRoutingTableEntry")->where("nodeId = ? AND destinationId = ?", array($theNodeId, $theRequest->destinationId))->execute();
			if($oldRoutes->count() == 0) {
				// Debugging
				echo "Keine alten Routen für Knoten {$theNodeId} gefunden. Neue Route zu Knoten {$theRequest->destinationId} wurde eingetragen.\n";
				
				$newRoutingTableEntry = new AODVRoutingTableEntry;
				$newRoutingTableEntry->nodeId = $theNodeId;
				$newRoutingTableEntry->destinationId = $theRequest->destinationId;
				$newRoutingTableEntry->nextHopId = $lastNodeId;
				$newRoutingTableEntry->destinationSequenceNumber = $theRequest->sequenceNumber;
				$newRoutingTableEntry->hopCount = $hopCount;
				$newRoutingTableEntry->timestamp = time();
				$newRoutingTableEntry->save();
			} else {
				foreach($oldRoutes as $theOldRoute) {
					if ($theOldRoute->destinationSequenceNumber < $theRequest->sequenceNumber) {
						// Debugging
						echo "Lösche veraltete Route (alte Seq {$theOldRoute->destinationSequenceNumber} < neue Seq {$theRequest->sequenceNumber}) von Knoten {$theNodeId} zu Knoten {$theRequest->destinationId}.\n";
						
						$theOldRoute->delete();
						$useRoute = true;
					}
				}
				
				if ($useRoute) {
					// Debugging
					echo "Neue Route von Knoten {$theNodeId} zu Knoten {$theRequest->destinationId} wurde eingetragen.\n";
					
					$newRoutingTableEntry = new AODVRoutingTableEntry;
					$newRoutingTableEntry->nodeId = $theNodeId;
					$newRoutingTableEntry->destinationId = $theRequest->destinationId;
					$newRoutingTableEntry->nextHopId = $lastNodeId;
					$newRoutingTableEntry->destinationSequenceNumber = $theRequest->sequenceNumber;
					$newRoutingTableEntry->hopCount = $hopCount;
					$newRoutingTableEntry->timestamp = time();
					$newRoutingTableEntry->save();
				}
			}
				
			$lastNodeId = $theNodeId;
			$hopCount++;
		}
	}
	
	public function createRouteForRREQFromExistingRoute($theRequest, $theRoute) {
		// Debugging
		echo "Route für RREQ mit sourceId {$theRequest->sourceId}, sequenceNumber {$theRequest->sequenceNumber} und Routingtabelleneintrag mit ID {$theRoute->id} erstellen.\n";
		
		$this->createRouteForRREQ($theRequest, $theRoute->hopCount);
		// Route in Gegenrichtung erstellen (Optimierung)
	}
	
	public function forwardRouteRequestToNeighbour($theRequest, $theNeighbour, $isUnitTest = false) {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		// prüfen ob Ziel wirklich noch in Reichweite und im Spiel
		if ($this->nodeIsInRange($theNeighbour) && $theNeighbour->battery > 0) {
			// RREQ in Buffer eintragen
			$this->addRouteRequestToBuffer($theRequest, $isUnitTest);

			// Debuggin
			if (!$isUnitTest) echo "RREQ mit sourceId {$theRequest->sourceId} und sequenceNumber {$theRequest->sequenceNumber} an Nachbarn mit ID {$theNeighbour->id} senden.\n";

			$theNewRREQ = $theRequest->copy();
			$theNewRREQ->currentNodeId = $theNeighbour->id;
			$theNewRREQ->lifespan--;
			$theNewRREQ->hopCount++;
			$theNewRREQ->processingRound = $gameSettings->currentRoutingMessageProcessingRound + 1;
			if (is_array($theNewRREQ->passedNodes)) {
				$theNewRREQ->passedNodes = array_merge($theNewRREQ->passedNodes, array($this->id));
			} else {
				$theNewRREQ->passedNodes = array($this->id);
			}
			$theNewRREQ->save();
		} else {
			// Debuggin
			if (!$isUnitTest) echo "RREQ mit sourceId {$theRequest->sourceId} und sequenceNumber {$theRequest->sequenceNumber} konnte nicht an Nachbarn mit ID {$theNeighbour->id} gesenden werden.\n";
		}
	}
	
	public function forwardRouteErrorToNeighbour($theError, $theNeighbour) {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		// prüfen ob Ziel wirklich noch in Reichweite und im Spiel
		if ($this->nodeIsInRange($theNeighbour) && $theNeighbour->battery > 0) {
			// Debuggin
			echo "RERR mit sourceId {$theError->sourceId} und destinationId {$theRequest->destinationId} an Nachbarn mit ID {$theNeighbour->id} senden.\n";
		
			$theNewRERR = $theError->copy();
			$theNewRERR->currentNodeId = $theNeighbour->id;
			$theNewRERR->sourceId = $this->id;
			$theNewRERR->processingRound = $gameSettings->currentRoutingMessageProcessingRound + 1;
			$theNewRERR->save();
		} else {
			// Debuggin
			echo "RERR mit sourceId {$theError->sourceId} und destinationId {$theRequest->destinationId} konnte nicht an Nachbarn mit ID {$theNeighbour->id} gesenden werden.\n";
		}
	}
	
	public function forwardDataPacketOnRoute($thePacket, $theRoute, $isUnitTest = false) {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		// prüfen ob Ziel wirklich noch in Reichweite und im Spiel
		if ($this->nodeIsInRange($theRoute->NextHop) && $theRoute->NextHop->battery > 0) {
			// Debuggin
			if (!$isUnitTest) echo "Datenpaket mit sourceId {$thePacket->sourceId} und destinationId {$thePacket->destinationId} an Nachbarn mit ID {$theRoute->nextHopId} senden.\n";
		
			$newPacket = $thePacket->copy();
			$newPacket->status = AODV_DATA_PACKET_STATUS_UNDERWAY;
			$newPacket->hopsDone++;
			$newPacket->currentNodeId = $theRoute->nextHopId;
			$newPacket->processingRound = $gameSettings->currentDataPacketProcessingRound + 1;
			// prüfen ob Paket Ziel erreicht hat
			if ($theRoute->nextHopId == $thePacket->destinationId) {
				// Debugging
				if (!$isUnitTest) echo "Datenpaket mit sourceId {$thePacket->sourceId} und destinationId {$thePacket->destinationId} hat sein Ziel erreicht.\n";

				$newPacket->status = AODV_DATA_PACKET_STATUS_ARRIVED;
				
				if ($newPacket->currentNodeId == $gameSettings->bonusGoal) {
					$newPacket->didReachBonusGoal = 1;
					$gameSettings->findNewBonusGoal(true);
				}
				
				$newPacket->awardPointsToOwner();
			}
			$newPacket->save();
		
			$this->score += 100;
			$this->battery = MAX(0, $this->battery - 1);
			$this->save();
		} else {
			// Debuggin
			if (!$isUnitTest) echo "Datenpaket mit sourceId {$thePacket->sourceId} und destinationId {$thePacket->destinationId} konnte nicht an Nachbarn mit ID {$theRoute->nextHopId} gesenden werden.\n";
		}
	}
	
	public function sendRouteErrorToNeighbours($exceptionId, $isUnitTest = false) {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		// Debuggin
		if (!$isUnitTest) echo "RERR an alle Nachbarn betreffend Knoten mit ID {$exceptionId} senden.\n";
		
		$neighbours = Doctrine_Query::create()->from("Neighbour")->where("nodeId = ? AND neighbourId != ?", array($this->id, $exceptionId))->execute();
		foreach($neighbours as $theNeighbour) {
			$newRERR = new AODVRoutingMessage;
			$newRERR->type = AODV_ROUTING_MESSAGE_TYPE_RERR;
			$newRERR->destinationId = $exceptionId;
			$newRERR->sourceId = $this->id;
			$newRERR->currentNodeId = $theNeighbour->neighbourId;
			$newRERR->sequenceNumber = ++$this->sequenceNumber;
			$newRERR->processingRound = $gameSettings->currentRoutingMessageProcessingRound + 1;
			$newRERR->save();
			
			$this->save();
			$this->forwardRouteErrorToNeighbour($newRERR, $theNeighbour->Neighbour);
		}
	}
	
	public function sendRouteRequestToNeighbours($destinationId, $isUnitTest = false) {
		$gameSettings = Doctrine_Query::create()->from("Settings")->execute()->getFirst();
		
		// Debuggin
		if (!$isUnitTest) echo "RREQ an alle Nachbarn für Route zum Knoten mit ID {$destinationId} senden.\n";
		
		foreach($this->Neighbours as $theNeighbour) {
			$newRREQ = new AODVRoutingMessage;
			$newRREQ->type = AODV_ROUTING_MESSAGE_TYPE_RREQ;
			$newRREQ->destinationId = $destinationId;
			$newRREQ->sourceId = $this->id;
			$newRREQ->currentNodeId = $theNeighbour->id;
			$newRREQ->lifespan = 9;
			$newRREQ->sequenceNumber = ++$this->sequenceNumber;
			$newRREQ->processingRound = $gameSettings->currentRoutingMessageProcessingRound + 1;
			$newRREQ->hopCount = 0;
			
			$this->save();
			$this->forwardRouteRequestToNeighbour($newRREQ, $theNeighbour->Neighbour, $isUnitTest);
		}
	}
}